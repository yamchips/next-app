# Overview

Mosh's video was recorded in 2023 and Next.js and Tailwind have updated since then. Some features and configurations have already changed. This file records my learning notes.

## Intro video

The intro video (1h long, free version) contains following parts:

1. Routing and navigation
2. Client and server components
3. Data fetching
4. Caching
5. Static and dynamic rendering
6. Styling using globals.css
7. Styling using CSS modules
8. Styling using Tailwind CSS
9. Styling using DaisyUI

### Tailwind Installation

The installation method in the video is outdated. Follow the instructions in [Tailwind website](https://tailwindcss.com/docs/installation/framework-guides/nextjs) instead.

### DaisyUI

New theme should be added in globals.css instead of tailwind.config.ts.

## Routing and navigation

### Dynamic Routing

A dynamic route is a route with a parameter.

In the video, the parameter is used synchrounously, which triggers an Error in browser:

Server Error: Route "/users/[id]" used `params.id`. `params` should be awaited before using its properties.

To solve this problem, async and await are used, which is recommended in [Next.js website](https://nextjs.org/docs/messages/sync-dynamic-apis#possible-ways-to-fix-it) since the warning occurred on a Server component.

After adding async and await, a hint shows on await keyword saying "await has no effect on this type of expression".

To solve this problem, follow [Next.js website's](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#typescript) instruction to add a Promise type in the Props.

### Catch All Segments

Create products/[[...slug]] path and page.tsx file.

[[]] means the parameters are optional, ... means it can accept varying number of parameters.

Renaming [...slug] causes an error, so deleting and recreating is a better way.

### Accessing Query String Parameters

Modify UserTable.tsx, /users/page.tsx. Here, Server Side Rendering (SSR) is used, not Client Side Rendering (CSR) in game-hub project.

#### Traditional SSR, CSR and modern SSR

1. Traditional SSR

   Frontend: Receives a full HTML page from backend

   No need for JavaScript (though it can be added)

   Rendering is handled by the browser

   Backend: Generates and sends full HTML pages

   Features:
   <ul>
    <li>Good SEO</li>
    <li>Full page reloads, slow perceived performance</li>
    <li>Simple, no hydration issues</li>
   </ul>

2. Client-Side Rendering

   Frontend: Receives minimal HTML + JS bundle, builds UI in browser

   Backend: Sends JSON data only via APIs, Decoupled backend using REST or GraphQL

   Features:
    <ul>
    <li>Poor SEO</li>
    <li>No full page reloads, good perceived performance</li>
    <li>Fast but stale risk, UI may show old data if you don't revalidate or re-fetch at right time</li>
   </ul>

3. Modern SSR

   Frontend: Receives a full HTML page initially (pre-rendered or server-rendered)

   On navigation, only the changed parts of the page are sent (thanks to React Server Components)

   Runs a small JS runtime for client-side navigation and hydration

   Backend: Sends HTML (full or partial) generated on the server, fetch fresh data server-side

   Feature:

   <ul>
    <li>Good SEO</li>
    <li>No full page reloads, good perceived performance</li>
    <li>Fast and no stale risk</li>
    <li>Fresh data because rendering happens on every request </li>
   </ul>

#### Framework summary by architecture

| Architecture        | Frontend Frameworks                       | Backend Frameworks                                                          |
| ------------------- | ----------------------------------------- | --------------------------------------------------------------------------- |
| Traditional SSR     | (Browser renders HTML)                    | Ruby on Rails, Django, Laravel, ASP.NET, Spring Boot (with templates)       |
| CSR                 | React, Vue, Angular, Svelte, React Router | Spring Boot, Micronaut, Express.js, NestJS, Django REST, Flask, public APIs |
| Modern SSR (Hybrid) | Next.js 13+, Nuxt 3, Remix                | Next.js (backend built-in), Nuxt (backend built-in)                         |

#### Summary picture

<img src='./public/BackendFrontend.png' width='400' height='400'>

This picture was generated by ChatGPT.

#### Summary table

| Concept                     | My Project (App Router)      | Traditional SSR      | CSR (SPA style)             |
| --------------------------- | ---------------------------- | -------------------- | --------------------------- |
| Who intercepts link clicks? | Next.js client runtime       | Browser              | Client-side router          |
| Where is rendering done?    | Server via Server Components | Server (entire page) | Browser (React)             |
| Does it reload whole page?  | ‚ùå No                        | ‚úÖ Yes               | ‚ùå No                       |
| Data fetching               | Server                       | Server               | Client                      |
| SEO                         | ‚úÖ Great                     | ‚úÖ Great             | ‚ùå Poor (unless hydrated)   |
| Speed & UX                  | üöÄ Fast & smooth             | üê¢ Slow & janky      | ‚ö°Ô∏è Fast but freshness risk |

### Layout

Create admin folder which contains layout and page. A Layout component should have a parameter called children of type ReactNode. This prop represents the nested content that will be rendered. More specifically, in a layout.tsx, children refers to:

1. page.tsx at the same level
2. page.tsx at a lower level (in a subfolder) without its own layout.tsx
3. layout.tsx at a lower level

For example, in app/layout.tsx, children means:

1. app/page.tsx
2. app/users/pages.tsx
3. app/admin/layout.tsx

While in app/admin/layout.tsx, children means: app/admin/pages.tsx. And when visiting /admin, the render tree is:

1. app/layout.tsx (root)
2. app/admin/layout.tsx (nested layout)
3. app/admin/page.tsx (nested page ‚Üí becomes children of admin layout)

### Navigation

Link element in Next.js 13+:

only downloads the content of the target page, not the navigation bar or global css that applies to every page

pre-fetches links that are in the viewport

As we navigate in our app, Next.js stores the payload of our pages in a cache on the client. This cache only exists in one session and clears when we do a full page reload.

### Programmatic navigation

Take user to a new page as a result of clicking a button or submitting a form. Here we turn /users/new/page.tsx into a client componet because we want to make a form on this page, and we cannot handle browser events in a server component.

When importing router, import it from next/navigation instead of next/router. The latter is the old version (page router).

### Showing loading UIs

Add Suspense element around the target element, edit fallback attribute to define what users see when loading.

If we want to set loading UIs between different pages, we can:

1. in root layout.tsx, wrap children with Suspense
2. create loading.tsx under app folder

Loading file in child folder overrides loading file in parent folder.

| Navigation Target              | Which loading.tsx?               |
| ------------------------------ | -------------------------------- |
| /                              | app/loading.tsx                  |
| /users                         | app/users/loading.tsx            |
| /users/abc                     | app/users/loading.tsx            |
| no matching nested loading.tsx | Inherits from parent loading.tsx |

### Handling not found

If a not-found.tsx is put under app/ folder, it is responsible for handling localhost:3000/unknown.

If it is put under a subfolder, such as app/users, we need a [] or [[...slug]] subfolder and a page.tsx inside that folder to call notFound function. It is for handling localhost:3000/users/39.

### Handling errors

Creating an error.tsx in app/ folder can catch all errors. We can also create an error.tsx in a subfolder to handle all the errors happen in any of the routes under this subfolder.

The errors happen in layout.tsx cannot be detected by error.tsx. A global-error.tsx needs to be created under app folder.

To log error in real world, a tool called [Sentry](https://sentry.io/welcome/) is recommended.

We can pass a reset function to this error.tsx file to retry loading current page. If so, we need to set the component client side because we need to deal with onClick event.

## Build APIs

### Get a collection of objects

Create a subfolder api/users and a route.tsx. Use static data for now.

If the parameter request: NextRequest is deleted, Next.js caches the result of this response. So, even it's not used, we should keep it.

### Get a single object

Create a subfolder api/users/[id] and a route.tsx. Use static data for now.

### Create an object

In api/users/route.tsx, add a new POST function. Use Postman to test creating an object.
