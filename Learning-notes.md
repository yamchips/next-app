# Overview

Mosh's video was recorded in 2023 and Next.js and Tailwind have updated since then. Some features and configurations have already changed. This file records my learning notes.

The intro video (1h long, free version) contains following parts:

1. Routing and navigation
2. Client and server components
3. Data fetching
4. Caching
5. Static and dynamic rendering
6. Styling using globals.css
7. Styling using CSS modules
8. Styling using Tailwind CSS
9. Styling using DaisyUI

## Tailwind Installation

The installation method in the video is outdated. Follow the instructions in [Tailwind website](https://tailwindcss.com/docs/installation/framework-guides/nextjs) instead.

## DaisyUI

New theme should be added in globals.css instead of tailwind.config.ts.

## Dynamic Routing

A dynamic route is a route with a parameter.

In the video, the parameter is used synchrounously, which triggers an Error in browser:

Server Error: Route "/users/[id]" used `params.id`. `params` should be awaited before using its properties.

To solve this problem, async and await are used, which is recommended in [Next.js website](https://nextjs.org/docs/messages/sync-dynamic-apis#possible-ways-to-fix-it) since the warning occurred on a Server component.

After adding async and await, a hint shows on await keyword saying "await has no effect on this type of expression".

To solve this problem, follow [Next.js website's](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#typescript) instruction to add a Promise type in the Props.

## Catch All Segments

Create products/[[...slug]] path and page.tsx file.

[[]] means the parameters are optional, ... means it can accept varying number of parameters.

Renaming [...slug] causes an error, so deleting and recreating is a better way.

## Accessing Query String Parameters

Modify UserTable.tsx, /users/page.tsx. Here, Server Side Rendering (SSR) is used, not Client Side Rendering (CSR) in game-hub project.

### Traditional SSR, CSR and modern SSR

1. Traditional SSR

   Frontend: Receives a full HTML page from backend

   No need for JavaScript (though it can be added)

   Rendering is handled by the browser

   Backend: Generates and sends full HTML pages

   Features:
   <ul>
    <li>Good SEO</li>
    <li>Full page reloads, slow perceived performance</li>
    <li>Simple, no hydration issues</li>
   </ul>

2. Client-Side Rendering

   Frontend: Receives minimal HTML + JS bundle, builds UI in browser

   Backend: Sends JSON data only via APIs, Decoupled backend using REST or GraphQL

   Features:
    <ul>
    <li>Poor SEO</li>
    <li>No full page reloads, good perceived performance</li>
    <li>Fast but stale risk, UI may show old data if you don't revalidate or re-fetch at right time</li>
   </ul>

3. Modern SSR

   Frontend: Receives a full HTML page initially (pre-rendered or server-rendered)

   On navigation, only the changed parts of the page are sent (thanks to React Server Components)

   Runs a small JS runtime for client-side navigation and hydration

   Backend: Sends HTML (full or partial) generated on the server, fetch fresh data server-side

   Feature:

   <ul>
    <li>Good SEO</li>
    <li>No full page reloads, good perceived performance</li>
    <li>Fast and no stale risk</li>
    <li>Fresh data because rendering happens on every request </li>
   </ul>

### Framework summary by architecture

| Architecture        | Frontend Frameworks                       | Backend Frameworks                                                          |
| ------------------- | ----------------------------------------- | --------------------------------------------------------------------------- |
| Traditional SSR     | (Browser renders HTML)                    | Ruby on Rails, Django, Laravel, ASP.NET, Spring Boot (with templates)       |
| CSR                 | React, Vue, Angular, Svelte, React Router | Spring Boot, Micronaut, Express.js, NestJS, Django REST, Flask, public APIs |
| Modern SSR (Hybrid) | Next.js 13+, Nuxt 3, Remix                | Next.js (backend built-in), Nuxt (backend built-in)                         |

### Summary picture

<img src='./public/BackendFrontend.png' width='400' height='400'>

This picture was generated by ChatGPT.

### Summary table

| Concept                     | My Project (App Router)      | Traditional SSR      | CSR (SPA style)             |
| --------------------------- | ---------------------------- | -------------------- | --------------------------- |
| Who intercepts link clicks? | Next.js client runtime       | Browser              | Client-side router          |
| Where is rendering done?    | Server via Server Components | Server (entire page) | Browser (React)             |
| Does it reload whole page?  | ‚ùå No                        | ‚úÖ Yes               | ‚ùå No                       |
| Data fetching               | Server                       | Server               | Client                      |
| SEO                         | ‚úÖ Great                     | ‚úÖ Great             | ‚ùå Poor (unless hydrated)   |
| Speed & UX                  | üöÄ Fast & smooth             | üê¢ Slow & janky      | ‚ö°Ô∏è Fast but freshness risk |

## Layout

Create admin folder which contains layout and page. A Layout component should have a parameter called children of type ReactNode. This prop represents the nested content that will be rendered. More specifically, in a layout.tsx, children refers to:

1. page.tsx at the same level
2. page.tsx at a lower level (in a subfolder) without its own layout.tsx
3. layout.tsx at a lower level

For example, in app/layout.tsx, children means:

1. app/page.tsx
2. app/users/pages.tsx
3. app/admin/layout.tsx

While in app/admin/layout.tsx, children means: app/admin/pages.tsx. And when visiting /admin, the render tree is:

1. app/layout.tsx (root)
2. app/admin/layout.tsx (nested layout)
3. app/admin/page.tsx (nested page ‚Üí becomes children of admin layout)
